from Tkinter import *
import tkFileDialog
from music21 import *
from eventBasedAnimationClass import EventBasedAnimationClass

class PositionInput(object):
    def __init__(self,path,measure,n,finger,string=None):
        self.path = path
        self.score  = converter.parse(self.path)
        self.vlnPart = self.score.getElementById('Violin')
        self.measure = self.vlnPart.measure(measure)
        self.n = note.Note(n)
        self.finger = finger
        self.string  = string
        
    def inputPosition(self):
        for note in self.measure:
            if note == self.n:
                note.addLyric(self.finger)
                if self.string!=None:
                    note.addLyric(self.string)
        

class FingerMap(object):
    def __init__(self,path):
        self.path = path
        self.score  = converter.parse(self.path)
        #self.score = 
        self.vlnPart = self.score.getElementById('Violin')
        # the index of the list represents the half steps from the string note the position is on
        # there can be multiple possible positions for a half step
        self.positions = [[1],[1],[1],[2],[2],[3],[3,4],[4],[5],[5],[6],[6],[7],[7],[8]]
        self.position = 1
        self.strings = ['G3','D4','A4','E5']
        self.string = None
        # the index of the list represents the half steps from the initial note of the position
        # there can be multiple possible fingers for a half step
        self.fingers = [[1],[1,2],[2,3],[3],[3,4],[4],[4]]
        self.finger = None
        self.map = []
        
    def getFingerMap(self):
        """returns the finger map, represented by a list of tuples that contain
            which position, string, and finger the note is"""
        # loops through all the notes in the violin part
        for n in self.vlnPart.flat.notesAndRests:
            # if the note is not a rest
            if not n.isRest:
                # if the note has a lyric, change position
                if n.lyric:
                    # findPostion also gets string
                    self.findPosition(n)
                    self.finger= n.lyric
                else:
                    self.getString(n)
                    self.findFingerNum(n)
                self.map += [(n,self.position,self.string,self.finger)]
        return self.map
               
    def getPositionNum(self,initPos,n):
        # gets the list of possible positions for half steps from string to the note
        # position starts on
        distance = initPos.semitones
        possible = self.positions[distance]
        # if there is more than one possible position
        if len(possible)>1:
            # if the enharmonic of the note is "higher" (the pitch refers to a higher note,
            # even though they are the same note)
            if ord(str(n.pitch.getEnharmonic())[0])>ord(str(n.pitch)[0]):
                return min(possible)
            return max(possible)
        return possible[0]
        
    def getInitPosition(self,n):
        """gets the interval between the string and the note where the first finger on that position is"""
        # note where first finger on that position is
        initPosNote= note.Note(chr(ord(str(n.pitch)[0]) + (int(n.lyric)-1))+str(n.pitch)[1])
        return self.getInterval(note.Note(self.string),initPosNote)
        
    def findAllPossiblePositions(self,n):
        possible = []
        for string in self.strings:
            # loop through the notes on a string (2 octaves)
            for p in scale.ChromaticScale(string).getPitches(string,string[0]+str(int(string[1])+2)): 
                # if its either an enharmonic or the same note
                if (not(n.pitch==p) and not(n.pitch<p) and not(n.pitch>p))or (n.pitch==p):
                    initPos = self.getInitPosition(n)
                    possible += [(self.getPositionNum(initPos,n),string)]
        return possible
                
    def findPosition(self,n):
        # if the specific string of the position is indicated,
        # change position to the one on that string
        if len(n.lyrics)==2:
            # the string is indicated after which finger
            self.string = n.lyrics[1]
            initPos = self.getInitPosition(n)
            self.position = self.getPositionNum(initPos,n)
        # if the finger is 0 (open string)
        # change to first position
        elif n.lyric==0:
            self.position = 1
            self.string = self.getString(n)
        else:
            # for the finger number given, there are up to four possible positions
            possible = self.findAllPossiblePositions(n)
            # get the scores of each position, choose position with best score
            # score is determined by how many strings crossed and how high up 
            # position is, lowest score is the best
            positionScores = []
            for position,string in possible:
                prevString = self.map[-1][1]
                # each string is a perfect fifth apart (or 7 half steps)
                intrvl = self.getInterval(note.Note(string),note.Note(prevString))
                distance = intrvl.semitones
                numStringsCrossed = abs(distance/7)
                score = position+numStringsCrossed
                positionScores += [(position,score)]
            # find the least score
            scores = []
            for i in xrange(len(positionScores)):
                scores += [(positionScores[i])[1]]
            bestScore = min(scores)
            i = scores.index(bestScore)
            self.position = positionScores[i][0]
            self.string = string
                    
    def getInterval(self,note1,note2):
        return interval.Interval(note1, note2)

    def getString(self,n):
        print "n",n.pitch
        for string in self.strings:
            print "string", string
            if self.position==1:
                initPos = interval.Interval(2)
            else:
                initPos = interval.Interval(self.positions.index([self.position]))
            initPosNote = note.Note(interval.transposePitch(pitch.Pitch(string),initPos))
            print 'initPosNote', initPosNote.pitch
            intrvl = self.getInterval(initPosNote,n)
            print 'interval', intrvl
            distance = intrvl.semitones
            print "distance", distance
            # strings are a perfect fifth apart (7 half steps)
            if 0<=distance<=7:
                self.string = string
                print "self.s", self.string
    
    def findFingerNum(self,n):
        if self.position == 1:  
            initPos = interval.Interval(2)
            #print "n", n
            #print "initPos",initPos
        else:
            initPos = interval.Interval(self.positions.index([self.position]))
        initPosNote = note.Note(interval.transposePitch(pitch.Pitch(self.string),initPos))
        #print "initPosNote",initPosNote
        intrvl= self.getInterval(initPosNote,n)
        #print "interval", intrvl
        distance = intrvl.semitones
        #print "distance", distance
        possible = self.fingers[distance]
        p1 = str(n.pitch.getEnharmonic())[0]
        p2 = str(n.pitch)[0]
        print "p1", p1
        print "p2", p2
        if ord(str(n.pitch.getEnharmonic())[0]) > ord(str(n.pitch)[0]):
            self.finger = min(possible)
        else:
            self.finger = max(possible)
      
        
class ViolinAnimation(EventBasedAnimationClass):
    def __init__(self):
        super(ViolinAnimation,self).__init__(1120,400)
        #self.path = tkFileDialog.askopenfilename()
        self.timerDelay = 1000
        
    def onMousePressed(self,event):
        if (0,self.height)<=(event.x,event.y)<=(self.width/10,9*self.height/10):
            self.playing = not self.playing
        
    def onKeyPressed(self,event):
        # debugging
        if event.char=='d':
            self.showHalfSteps = True
        elif event.char=='s':
            self.start= True
        elif event.char=='r':
            self.place= 0
        
    def getYValue(self,x):
        w = self.width
        h = self.height
        if self.string=='E5':
            slopeE = (((h/2-(3*(8*h/100)/2))-(h/2-(3*(4*h/100)/2)))/((9*w/10)-(w/10)))+1
            return (slopeE*(x-w/10))+(h/2-(3*(4*h/100)/2))
            
        elif self.string=='A4':
            slopeA = (((h/2-((8*h/100)/2))-(h/2-((4*h/100)/2)))/((9*w/10)-(w/10)))+1
            print "slopeA",slopeA
            return (slopeA*(x-w/10))+(h/2-((4*h/100)/2))
        elif self.string=='D4':
            
            slopeD = ((h/2+((8*h/100)/2))-(h/2+((4*h/100)/2)))/((9*w/10)-(w/10))
            print "slopeD",slopeD
            return (slopeD*(x-w/10))+(h/2+((4*h/100)/2))
        else:
            slopeG = ((h/2+(3*(8*h/100)/2))-(h/2+(3*(4*h/100)/2)))/((9*w/10)-(w/10))
            print "slopeG", slopeG
            return (slopeG*(x-w/10))+(h/2+(3*(4*h/100)/2))
            
    def getScale(self,distance):
        return distance*(448*self.halfStep/10000)
        #1.0/(((distance*(distance-1))/2)+1)
        
    def sumOfHalfSteps(self,distance):
        sum = 0
        for d in xrange(distance,-1,-1):
            sum += int(round(self.halfStep-self.getScale(d)))
        return sum
            
    def findFingerPlace(self):
        initPos = FingerMap(self.path).getInterval(note.Note(self.string),self.note)
        distance = initPos.semitones
        self.markerX=(self.width/10)+self.sumOfHalfSteps(distance)
        print "x", self.markerX
        self.markerY = self.getYValue(self.markerX)
        print "y", self.markerY
        
    def playAudio(self):
        whole = stream.Stream()
        part= stream.Part()
        part.append(self.note)
        whole.append(part)
        audio = midi.realtime.StreamPlayer(whole)
        audio.play()
        
    def onTimerFired(self):
        if self.place<=(len(self.map)-2) and self.playing:
            self.place += 1
            print self.place
            (self.note,self.position,self.string,self.finger) = self.map[self.place]
            self.findFingerPlace()
            self.color = self.colors[self.position-1]
            self.playAudio()
        elif self.place>(len(self.map)-2):
            self.place = -1
            self.playing = False
            
    def drawStartScreen(self):
        self.canvas.create_rectangle(0,0,self.width,self.height,fill = "teal")
        self.canvas.create_text(self.width/2,0,anchor = "center",text ="Violin Cheat Sheet",font = "Arial 20 bold",fill = "red")
        self.canvas.create_rectangle(self.width/2-(5*self.width/100),self.height/2-(11*self.height/100),self.width/2+(5*self.width/100),self.height/2-(1*self.height/100),fill = "blue")
        self.canvas.create_text(self.width/2,self.height/2+(6*self.height/100),anchor = "center",text = "Instructions",font = "Arial 20 bold",fill = "grey")
        self.canvas.create_rectangle(self.width/2-(5*self.width/100),self.height/2+(1*self.height/100),self.width/2+(5*self.width/100),self.height/2+(11*self.height/100),fill = "blue")
        self.canvas.create_text(self.width/2,self.height/2-(6*self.height/100),anchor = "center",text = "Choose Music",font = "Arial 20 bold",fill = "grey")
        
    def drawHelpScreen(self):
        self.canvas.create_rectangle(0,0,self.width,self.height,fill = "teal")
        self.canvas.create_text(self.width/2,0,anchor = "center",text = "Instructions",font="Arial 20 bold",fill = "red")
        self.canvas.create_text(self.width/2,self.height/3,anchor= "center",text = 
        
        
    
    def drawFingerBoard(self):
        width = self.width
        height = self.height
        self.canvas.create_polygon((width/10,height/2-(height/10)),
                                   (width/10,height/2+(height/10)),
                                   (9*width/10,height/2+(2*height/10)),
                                   (9*width/10,height/2-(2*height/10)),
                                   fill = 'black')
                                   
    def drawEString(self):
        self.canvas.create_line(self.width/10,self.height/2-(3*(4*self.height/100)/2),9*self.width/10,self.height/2-(3*(8*self.height/100)/2),fill= "blue")
        
    def drawAString(self):
        self.canvas.create_line(self.width/10,self.height/2-((4*self.height/100)/2),9*self.width/10,self.height/2-((8*self.height/100)/2),fill= "green")
        
    def drawDString(self):
        self.canvas.create_line(self.width/10,self.height/2+((4*self.height/100)/2),9*self.width/10,self.height/2+((8*self.height/100)/2),fill= "orange")
        
    def drawGString(self):
        self.canvas.create_line(self.width/10,self.height/2+(3*(4*self.height/100)/2),9*self.width/10,self.height/2+(3*(8*self.height/100)/2),fill= "red")
        
    def drawFingerMarker(self):
        self.canvas.create_oval(self.markerX+self.r,self.markerY+self.r,self.markerX-self.r,self.markerY-self.r, fill= self.color)
        
    def drawFingerNumber(self):
        self.canvas.create_text(self.markerX,self.markerY,anchor= "center",text= self.finger,fill= "grey", font= "Arial 10 bold")
        
    def drawPlayButton(self):
        self.canvas.create_rectangle(0,9*self.height/10,self.width/10,self.height, fill = "teal")
        self.canvas.create_polygon((3*self.width/100,92*self.height/100),(3*self.width/100,98*self.height/100),(6*self.width/100,95*self.height/100),fill = "red",outline = "black")
        
    def drawPauseButton(self):
        self.canvas.create_rectangle(0,9*self.height/10,self.width/10,self.height, fill = "teal")
        self.canvas.create_rectangle(3*self.width/100,93*self.height/100,4*self.width/100,97*self.height/100,fill = "red")
        self.canvas.create_rectangle(45*self.width/1000,93*self.height/100,55*self.width/1000,97*self.height/100,fill = "red")
        
    def redrawAll(self):
        self.canvas.delete(ALL)
        if self.startScreen:
            self.drawStartScreen()
        self.canvas.create_rectangle(0,0,self.width,self.height,fill = "white")
        if not self.playing:
            self.drawPlayButton()
        else:
            self.drawPauseButton()
        self.drawFingerBoard()
        self.drawEString()
        self.drawAString()
        self.drawDString()
        self.drawGString()
        if self.markerX!=None and self.markerY!=None:
            self.drawFingerMarker()
            self.drawFingerNumber()
        if (self.showHalfSteps):
            distance = -1
            x = 0
            while distance<24:
                distance += 1
                print "distance", distance
                scale = self.getScale(distance)
                print "scale", scale
                sum = self.sumOfHalfSteps(distance)
                print "sum",sum
                half = self.width/10
                print "half", half
                x = self.width/10+sum
                print "x", x
                self.canvas.create_line(x,self.height/2+(2*self.height/10),x,self.height/2-(2*self.height/10),fill = 'red')
        
    def initAnimation(self):
        self.startScreen = True
        #self.path = tkFileDialog.askopenfilename()
        self.playing = False
        self.showHalfSteps = False
        self.halfStep= 5*self.width/100
        self.place = -1
        #self.map = FingerMap(self.path).getFingerMap()
        #print self.map
        #(self.note,self.position,self.string,self.finger) = self.map[self.place]
        self.r = 10
        self.colors = ["white","orange","red","green","blue","purple","yellow","teal"]
        #self.color = self.colors[self.position-1]
        self.markerX = None
        self.markerY = None
        
        
#PositionInput('C:/Users/Amin/musicxml/Scale5.xml',1,'F#',1).inputPosition()
ViolinAnimation().run()
