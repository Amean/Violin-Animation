from Tkinter import *
from music21 import *
from eventBasedAnimationClass import EventBasedAnimationClass

class FingerMap(object):
    def __init__(self,path):
        self.path = path
        self.score  = converter.parse(self.path)
        self.vlnPart = self.score.getElementById('Violin')
        # the index of the list represents the half steps from the string note the position is on
        # there can be multiple possible positions for a half step
        self.positions = [[1],[1],[1],[2],[2],[3],[3,4],[4],[5],[5],[6],[6],[7],[7],[8]]
        self.position = 1
        self.strings = ['G3','D4','A5','E5']
        self.string = None
        # the index of the list represents the half steps from the initial note of the position
        # there can be multiple possible fingers for a half step
        self.fingers = [[1],[1,2],[2,3],[3,4],[3,4],[4],[4]]
        self.finger = None
        self.map = []
        
    def getFingerMap(self):
        """returns the finger map, represented by a list of tuples that contain
            which position, string, and finger the note is"""
        # loops through all the notes in the violin part
        for n in self.vlnPart.flat.notesAndRests:
            # if the note is not a rest
            if not n.isRest:
                # if the note has a lyric, change position
                if n.lyric:
                    # findPostion also gets string
                    self.findPosition(n)
                    self.finger= n.lyric
                else:
                    self.getString(n)
                    self.findFingerNum(n)
                self.map += [(n,self.position,self.string,self.finger)]
        return self.map
               
    def getPositionNum(self,initPos,n):
        # gets the list of possible positions for half steps from string to the note
        # position starts on
        possible = self.positions[initPos]
        # if there is more than one possible position
        if len(possible)>1:
            # if the enharmonic of the note is "higher" (the pitch refers to a higher note,
            # even though they are the same note)
            if ord(str(n.pitch.getEnharmonic())[0])>ord(str(n.pitch)[0]):
                return min(possible)
            return max(possible)
        return possible[0]
        
    def getInitPosition(self,n):
        """gets the interval between the string and the note where the first finger on that position is"""
        # note where first finger on that position is
        initPosNote= note.Note(chr(ord(str(n.pitch)[0]) + (int(n.lyric)-1))+str(n.pitch)[1])
        return self.getInterval(note.Note(self.string),initPosNote)
        
    def findAllPossiblePositions(self,n):
        possible = []
        for string in self.string:
            # loop through the notes on a string (2 octaves)
            for p in scale.ChromaticScale(string).getPitches(string,string[0]+str(int(string[1])+2)): 
                # if its either an enharmonic or the same note
                if (not(n.pitch==p) and not(n.pitch<p) and not(n.pitch>p))or (n.pitch==p):
                    initPos = getInitPosition(n)
                    possible += [(self.getPositionNum(initPos,n),string)]
        return possible
                
    def findPosition(self,n):
        # if the specific string of the position is indicated,
        # change position to the one on that string
        if len(note.lyrics)==2:
            # the string is indicated after which finger
            self.string = n.lyrics[1]
            initPos = self.getInitPosition(n)
            self.position = self.getPositionNum(initPos,n)
        # if the finger is 0 (open string)
        # change to first position
        elif note.lyric==0:
            self.position = 1
            self.string = self.getString(n)
        else:
            # for the finger number given, there are up to four possible positions
            possible = self.findAllPossiblePositions(n)
            # get the scores of each position, choose position with best score
            # score is determined by how many strings crossed and how high up 
            # position is, lowest score is the best
            positionScores = {}
            for position,string in possible:
                prevString = self.map[-1][1]
                # each string is a perfect fifth apart (or 7 half steps)
                numStringsCrossed = self.getInterval(string,prevString)/7
                score = position+numStringsCrossed
                positionScores += [(postion,score)]
            # find the least score
            scores = []
            for i in xrange(len(positionScores)):
                scores += posScores[i][1]
            bestScore = min(scores)
            i = scores.index(bestScore)
            self.position = positionScores[i][0]
            self.string = string
            
    def getDistance(self,intrvl):
        """takes music21 interval object and returns an int of the number of half steps"""
        distance = ""
        for c in str(intrvl):
            if c.isdigit():
                distance += c
        # this gets rid of the 21 from music21
        distance = distance[2:]
        return int(distance)
        
    def getInterval(self,note1,note2):
        return interval.notesToChromatic(note1, note2)

    def getString(self,n):
        for string in self.strings:
            if self.position==1:
                initPos = interval.Interval(1)
            else:
                initPos = interval.Interval(self.positions.index([self.position]))
            initPosNote = interval.transposeNote(note.Note(string),initPos)
            intrvl = self.getInterval(initPosNote,n)
            distance = self.getDistance(intrvl)
            # strings are a perfect fifth apart (7 half steps)
            if 0<=distance<=7:
                self.string = string
    
    def findFingerNum(self,n):
        if self.position == 1:
            initPos = interval.Interval(1)
        else:
            initPos = interval.Interval(self.positions.index([self.position]))
        initPosNote = interval.transposeNote(note.Note(self.string),initPos)
        intrvl= self.getInterval(initPosNote,n)
        distance = self.getDistance(intrvl)
        possible = self.fingers[distance]
        if ord(str(n.pitch.getEnharmonic())[0]) > ord(str(n.pitch)[0]):
            self.finger = min(possible)
        else:
            self.finger = max(possible)
      
        
class ViolinAnimation(EventBasedAnimationClass):
    def __init__(self,path):
        super(ViolinAnimation,self).__init__(1680,600)
        self.path = path
        self.timerDelay = 1000
        
    def onKeyPressed(self,event):
        # debugging
        self.showHalfSteps = True
        
    def getYValue(self,x):
        w = self.width
        h = self.height
        if self.string=='E5':
            slopeE = ((h/2-(3*(8*h/100)/2))-(h/2-(3*(4*h/100)/2)))/((9*w/10)-(w/10))
            return (slopeE*(x-w/10))+(h/2-(3*(4*h/100)/2))
        elif self.string=='A5':
            slopeA = ((h/2-((8*h/100)/2))-(h/2-((4*h/100)/2)))/((9*w/10)-(w/10))
            return (slopeA*(x-w/10))+(h/2-((4*h/100)/2))
        elif self.string=='D4':
            slopeD = ((h/2+((8*h/100)/2))-(h/2+((4*h/100)/2)))/((9*w/10)-(w/10))
            return (slopeD*(x-w/10))+(h/2+((4*h/100)/2))
        else:
            slopeG = ((h/2+(3*(8*h/100)/2))-(h/2+(3*(4*h/100)/2)))/((9*w/10)-(w/10))
            return (slopeG*(x-w/10))+(h/2+(3*(4*h/100)/2))
            
    def findFingerPlace(self):
        initPos = FingerMap(self.path).getInterval(note.Note(self.string),self.note)
        distance = FingerMap(self.path).getDistance(initPos)
        self.markerX=(int(round(distance*self.halfStep*self.scale)))+(self.width/10)
        self.markerY = self.getYValue(self.markerX)
        
    def onTimerFired(self):
        if self.place<=(len(self.map)-2):
            self.place += 1
            print self.place
            (self.note,self.position,self.string,self.finger) = self.map[self.place]
            self.findFingerPlace()
    
    def drawFingerBoard(self):
        width = self.width
        height = self.height
        self.canvas.create_polygon((width/10,height/2-(height/10)),
                                   (width/10,height/2+(height/10)),
                                   (9*width/10,height/2+(2*height/10)),
                                   (9*width/10,height/2-(2*height/10)),
                                   fill = 'black')
                                   
    def drawEString(self):
        self.canvas.create_line(self.width/10,self.height/2-(3*(4*self.height/100)/2),9*self.width/10,self.height/2-(3*(8*self.height/100)/2),fill= "blue")
        
    def drawAString(self):
        self.canvas.create_line(self.width/10,self.height/2-((4*self.height/100)/2),9*self.width/10,self.height/2-((8*self.height/100)/2),fill= "green")
        
    def drawDString(self):
        self.canvas.create_line(self.width/10,self.height/2+((4*self.height/100)/2),9*self.width/10,self.height/2+((8*self.height/100)/2),fill= "orange")
        
    def drawGString(self):
        self.canvas.create_line(self.width/10,self.height/2+(3*(4*self.height/100)/2),9*self.width/10,self.height/2+(3*(8*self.height/100)/2),fill= "red")
        
    def drawFingerMarker(self):
        self.canvas.create_oval(self.markerX+self.r,self.markerY+self.r,self.markerX-self.r,self.markerY-self.r, fill= self.color)
        
    def drawFingerNumber(self):
        self.canvas.create_text(self.markerX,self.markerY,anchor= "center",text= self.finger,fill= "grey", font= "Arial 10 bold")
        
    def redrawAll(self):
        self.canvas.delete(ALL)
        self.drawFingerBoard()
        self.drawEString()
        self.drawAString()
        self.drawDString()
        self.drawGString()
        if self.markerX!=None and self.markerY!=None:
            self.drawFingerMarker()
            self.drawFingerNumber()
        if (self.showHalfSteps):
            distance = 0
            x = 0
            while x<=(9*self.width/10):
                distance += 1
                x = self.width/10+int(round(distance*self.halfStep*self.scale))
                self.canvas.create_line(x,self.height/2+(2*self.height/10),x,self.height/2-(2*self.height/10),fill = 'red')
        
    def initAnimation(self):
        self.showHalfSteps = False
        self.scale= 1.0/2
        self.halfStep= self.width/10
        self.place = 0
        self.map = FingerMap(self.path).getFingerMap()
        print self.map
        (self.note,self.position,self.string,self.finger) = self.map[self.place]
        self.r = 10
        self.colors = ["white","orange","red","green","blue","purple","yellow","teal"]
        self.color = self.colors[self.position-1]
        self.markerX = None
        self.markerY = None
        
ViolinAnimation('C:/Users/Amin/musicxml/Scale.xml').run()
